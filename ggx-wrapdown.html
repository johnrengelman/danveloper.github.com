<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Groovy &amp; Grails Exchange Wrapdown</title>
<link rel="stylesheet" href="./assets/css/asciidoctor.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="article">
<div id="header">
<h1>Groovy &amp; Grails Exchange Wrapdown</h1>
<span id="author">Dan Woods</span><br>
<span id="email"><a target="_blank" href="http://twitter.com/danveloper" target="_blank">@danveloper</a></span><br>
<span id="revdate">2013-12-23</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This past week, I was once again humbled and privileged to find myself amongst the experts of the Groovy and Grails community at the Groovy &amp; Grails Exchange (GGX) in London. During the conference, I had the opportunity to speak to, and learn from, some of the most knowledgable people for which I have ever met. I was also honored to share some of my thoughts and experiences with the other conference goers through the presentations that I gave on Groovy and Grails development. Ultimately though, I was again reminded that these gatherings are more than anything about meeting and hanging out with the people from our little niche of the greater open source community.</p>
</div>
<div class="paragraph">
<p>The conference kicked off with an opening keynote from <a target="_blank" href="https://twitter.com/glaforge">Guillaume Laforge</a>, which outlined in deep technical detail the new features of Groovy 2.2. Truthfully, I was unprepared for the level of technical detail that Guillaume gave during the keynote, but it was a pleasent surprise. I was very happy that the content of the presentation was not a sales pitch for Groovy or <a target="_blank" href="http://gopivotal.com/">Pivotal</a>, which was something that I was afraid of when he started off with a corporate slide deck. It was great to see him instead filling in the technical details of the "how&#8217;s" and "why&#8217;s" for some of the new features that they&#8217;re supporting in Groovy 2.2.</p>
</div>
<div class="paragraph">
<p>Some of the new features available in Groovy 2.2 include:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Method exclusions from <code>@Delegate</code> objects</p>
</li>
<li>
<p>Grab configuration uses <a target="_blank" href="https://bintray.com/bintray/jcenter">Bintray&#8217;s JCenter</a> before Maven Central</p>
</li>
<li>
<p>The <code>doc</code> command in Groovysh will open javadoc and groovydoc in new browser tabs</p>
</li>
<li>
<p>Ability to change a Groovy Script&#8217;s <code>BaseScript</code> using the <code>@BaseScript</code> transform</p>
</li>
<li>
<p>New <code>@Log4j2</code> transform for logging</p>
</li>
<li>
<p><code>@DelegatesTo</code> now has a <code>genericTypeIndex</code> to give IDEs a hint to the type of a generic list</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method exclusion feature of the <code>@Delegate</code> transform in Groovy 2.2 is more powerful than it may initially seem. This basically allows you to change a class' runtime functionality without having to explicitly override any part of its MetaClass. Consider the following example, which demonstrates a primitive model that represents a hotel booking:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.Canonical

@Canonical
class HotelBooking {
  @Delegate(excludes =  ['after']) Date checkIn
  @Delegate(excludes = ['before']) Date checkOut

  String toString() {
    "checkIn=[$checkIn],checkOut=[$checkOut]"
  }
}

def booking = new HotelBooking(Date.parse("yyyy-MM-dd", "2013-12-11"), Date.parse("yyyy-MM-dd", "2013-12-19"))
assert booking.before(Date.parse("yyyy-MM-dd", "2013-12-12"))
assert !booking.after(Date.parse("yyyy-MM-dd", "2013-12-21"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given the ability to exclude methods from the delegates means that we can maintain multiple data points that we treat as a single, unified entity. From a practical implementation standpoint, this means that our service layer or utility classes can be greatly simplified (or, in some cases, even eliminated!) because our model is able to act in the way that we think it should.</p>
</div>
<div class="paragraph">
<p>Equally impressive is the ability for a script to define its own context through the <code>BaseScript</code> transform. This is another improvement to the Groovy language that allows it to act as a powerful utility for building domain specific languages. Given this functionality, we can easily create a class of reusable methods and low-level logic to sit beneath scripts that are designed as business-specific operations. For example, consider the following script that emulates a handler for some websocket communication:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>import groovy.transform.BaseScript

@BaseScript Context context

abstract class Context extends Script {
  def onconnect = {}
  def onopen    = {}
  def onclose   = {}
  def onmessage = {}

  void onOpen(c)    { this.onopen = c    }
  void onConnect(c) { this.onconnect = c }
  void onMessage(c) { this.onmessage = c }
  void onClose(c)   { this.onclose = c   }

  void send(msg)    { println "sent $msg" }

  // For demonstrative purposes only
  void open()       { this.onopen()     }
  void connect()    { this.onconnect()  }
  void message(m)   { this.onmessage(m) }
  void close()      { this.onclose()    }
}

// "Business Logic" code
onOpen    { send "hello"   }
onConnect { send "welcome" }
onMessage { String m -&gt; println "received: $m" }
onClose   { send "goodbye" }

// These would be called from the container
open()
connect()
message("great to see you!")
close()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Were this not a contrived example, the context class would be extracted to the project, and the script would only contain the "<code>on</code>*" methods and the <code>BaseScript</code> definition. The "business logic" in this script is the code that is contained in the handler closures. This is important functionality because it allows the script to describe its functionality to the compiler, as opposed to the compiler dictating the script&#8217;s context. This gives a great deal of power to the developer when writing Groovy scripts.</p>
</div>
<div class="paragraph">
<p>After discussing the recent improvements in Groovy 2.2, Guillaume went on to discuss future plans for Groovy 3. In this, he outlined plans for Groovy to adopt the concept of Traits, which will actually come on-the-road-to-Groovy-3, and plan to be introduced with Groovy 2.3, in Q2 of 2014. Traits are essentially a strategy for multiple inheritence, and, in practice, are not terribly dissimilar from Groovy&#8217;s existing faculty of Mixins. There&#8217;s some benefit, however, in being able to explicitly implement a Trait, and in that, the functionality mirrors nicely with interface defaults in Java 8. The trade-off there, however, is that interfaces in Java 8 cannot maintain state, whereas a Trait should have stateful functionality, and Guillaume noted that Groovy 3 Traits would be stateful. This is an exciting feature on the horizon, as it means that Groovy is working toward providing better structure for its dynamic, runtime nature, and overall it shows a progressing maturity in the language.</p>
</div>
<div class="paragraph">
<p>Groovy 3 will also bring a <code>TailRecursion</code> transform for methods, that will trick the runtime system into emulating tail call optimization so that the stack doesn&#8217;t overflow when making a ton of recursive calls. For those who are familiar with Groovy&#8217;s "Trampoline" functionality, this transform can essentially be thought of as trampoline-for-methods. The transform will apply at the method level, and will ensure a vomiting of fibonacci sequence generating blog posts. Yipee.</p>
</div>
<div class="paragraph">
<p>Guillaume also announced that the Groovy reference docs will be getting an update to look more modern and "sexy", and will be written with Asciidoc. But that statement was entirely overshadowed by the following discussion on Groovy 3&#8217;s revamping of the Meta Object Protocol. With the lessons learned through Groovy 2, the next version of Groovy will introduce substantial changes to the MOP, and will offer an array of new features. Most notably, the new MOP will heavily leverage the <code>invokeDynamic</code> instruction for improved performance, which means that Groovy 3 will be heavily invested in JDK 7+. Further improvements to the MOP include the introduction of the <em>"realm"</em> concept, which provides MetaClass isolation so that libraries or external classes cannot make changes to MetaClasses that they should not be able to. Realms in the new MOP will be stacked, where each realm has its own MetaClass. Changes to a MetaClass are visible upwards, which means that library and lower-level MetaClasses can remain untouched by project code and will therefore always perform in a predictable manner. To demonstrate the concept of Realms, consider the following example model and service classes:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class User {
  Long id
  String username
  String email

  // for demonstrative purposes
  static findByUsername(String username) {
      [id: 1, username: "dan", email: "danielpwoods@gmail.com"] as User
  }
}

class RestService {
  // for demonstrative purposes
  def retrieveAttributes(String email) {
    [
      username: "dan",
      name: [firstName: "Dan", lastName: "Woods"],
      address: [street: "123 Main St", city: "Minneapolis", state: "MN"]
    ]
  }
}

class Service {
  def restService = new RestService()

  Map compose(User user, Map attributes) {
    [composed: true,
         name: "$attributes.name.firstName $attributes.name.lastName",
        email: "$user.email",
           id: "$user.id"]
  }

  def lookup(String email) {
    def attrs = restService.retrieveAttributes(email)
    User user = User.findByUsername(attrs.username)
    compose user, attrs
  }
}

// User code
def service = new Service()
service.lookup "danielpwoods@gmail.com"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume for the sake of conversation that our service classes were coming from a library or module that we had already crafted for reusability. In today&#8217;s MOP, we could totally change the functionality of this library by overriding the <code>RestService</code>'s <code>retrieveAttributes</code> method:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>RestService.metaClass.retrieveAttributes = { String email -&gt; [lol: "yeah_right"] }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the Service class will throw a <code>NullPointerException</code> when trying to pull the username off of the <code>attrs</code> object, because that property doesn&#8217;t exist on the response from the <code>RestService</code>. With the MOP&#8217;s method dispatching, when the <code>Service</code> class makes the call to the <code>RestService</code>, the call is delegated through Groovy&#8217;s runtime system, which holds a one-to-one registry of Class-to-MetaClass. The method invocation first looks at the Class' MetaClass to see if a MetaMethod exists, and if it does, it invokes that <code>MetaMethod</code> as a priority. This dynamic functionality provides a great deal of benefit when developing versatile systems, but as a library developer, it can be difficult to ensure that your code is designed in a way that is rigid against injections that don&#8217;t conform to your code&#8217;s specification.</p>
</div>
<div class="paragraph">
<p>The new MOP will take care of this scenario by providing a MetaClass for each "realm", where a library will have its own realm, and user code its own as well. That will allow the original <code>retrieveAttributes</code> method on the <code>RestService</code> class to be called as expected by the Service class, but will also allow our User code to affect MetaClass behavior in the context of our application code&#8217;s runtime system. To be more specific, given the above example, if we override <code>retrieveAttributes</code>, the library&#8217;s behavior won&#8217;t change when calling that function because its MetaClass will remain unaffected, but when our User code calls that method we will actually get the result of our injected override. This isolation is a major improvement to the MOP and continues Groovy&#8217;s trend of progressive maturity by ensuring that code will work in the manner in which it was designed, thereby reducing unpredictable (or sometimes accidental!) behavior.</p>
</div>
<div class="paragraph">
<p>Other MOP improvements with Groovy 3 include method shadowing rules that determine which method will be called when an extension class overrides a private method with the same signature. To demonstrate this, considering the following service class, which makes use of a private method for handling service-layer logic:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class Service {
  private String find(String username) {
    "private lookup"
  }

  String lookup(LinkedHashMap attrs) {
    find attrs.username
  }
}

def service = new Service()
service.lookup([username: "username"])</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we run this code, we get the result that we would expect, "private lookup". In today&#8217;s MOP, given the method dispatching workflow that we&#8217;ve already disucssed, if&#8201;&#8212;&#8201;from some other part of our code&#8201;&#8212;&#8201;we offer the <code>Service</code> class' MetaClass a closure of the same signature as the <code>find</code> method, that closure will be called instead of the method that is defined on the class. For example:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class Service {
  private String find(String username) {
    "private lookup"
  }

  String lookup(LinkedHashMap attrs) {
    find attrs.username
  }
}

Service.metaClass.find = { String username -&gt;
 "overridden"
}

def service = new Service()
service.lookup([username: "username"])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time when we run the code, we get the result, "overridden" instead of "private lookup". In the future, this will no longer be the case. The shadowing rules that are being defined for Groovy 3 will mean that the private <code>find</code> method will be called when the invocation originates from the <code>Service</code> class. We&#8217;ll still be able to provide a closure with the same signature to the MetaClass, but only calls that originate from outside of the <code>Service</code> class will ever have that method invoked.</p>
</div>
<div class="paragraph">
<p>Suffice it to say, this is a very exciting time to be a part of the Groovy community, and Guillaume&#8217;s opening day keynote at GGX really spurred excitement for the rest of the conference.</p>
</div>
<div class="paragraph">
<p>After the keynote, I attended a talk from <a target="_blank" href="https://twitter.com/alvaro_sanchez">Alvaro Sanchez</a> entitled <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/devqa-make-your-testers-happy-with-groovy-spock-and-geb">"DevQA"</a>. Alvaro&#8217;s presentation was all about real world experience with testing Grails applications. He talked about a lot of things, mostly from the standpoint of a work environment where development and QA were separate groups within the organization. He discussed structuring Grails applications in a way that would make it easy for non-developer QA to run automated tests. In his presentation, Alvaro even discussed how he built a spock extension to discriminate the environment in which tests would run, so that certain tests could be run for certain environments. I think this is a very interesting and useful concept, and I hope that he open sources the code. Alvaro&#8217;s slides were also nicely designed, which made it visually very easy to follow.</p>
</div>
<div class="paragraph">
<p>After that, I was drawn by its title to <a target="_blank" href="https://twitter.com/marcinerdmann">Marcin Erdmann</a>'s talk, <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/modern-groovy-enterprise-stack">"Modern Enterprise Groovy"</a>. This is a topic near-and-dear to my heart, and Marcin didn&#8217;t disappoint. I highly recommend watching this video for anybody who was unable to attend. Also, if you are fortunate enough to attend a future conference where Marcin is presenting, his talks are not to be missed. He is an active contributor to nearly every open source project in the Groovy ecosystem, and he brings a ton of experience and understanding to the field. Marcin&#8217;s talk discussed using Spring Integration to build high-throughput, distributed systems backed with RabbitMQ. To simplify his Spring Integration configuration, Marcin wrote a custom XML NS and Namespace Handler that builds all of the beans necessary for his project. As he describes, he was able to drastically simplify his project&#8217;s configuration, and more heavily utilize annotation configuration, which he finds more maintainable and testable. I&#8217;m very excited about Marcin&#8217;s custom namespace for Spring Integration, because I am a victim of the XML verbosity required to build a non-trivial Spring Integration application. I hope that he open sources it. I talked to him about open sourcing it, and he explained to me that to make it something that other people could use outside of his organization, he&#8217;s have to build in all of the capabilities that already exist with the existing Spring Integration XML configuration. It makes sense, but I hope that he can find a way to offer some simplified namespace support that assumes reasonable defaults. To note, Marcin is using Dropwizard with Spring to build micro-services, which I thought was a very cool approach to his problem domain. I think the benefits offered in this area by Spring Boot will make a compelling case for future change, and for those who have chosen to integrate Spring with Dropwizard, they will find an easy migration path that includes great simplifications to their project&#8217;s architecture. There wasn&#8217;t much code during his presentation, but overall I would say that&#8217;s ok. I do wish that he had gone a little bit more in depth on the Spring Integration customizations, and had shown some example application that demonstrated his distributed architecture, but his slides were comprehensive and conveyed the material points very well. Marcin is an expert in Enterprise development, and I sincerely hope that he brings that expertise to the US conferences in the coming year; I look forward to his future presentations.</p>
</div>
<div class="paragraph">
<p>One does not simply miss a <a target="_blank" href="http://twitter.com/ldaley">Luke Daley</a> talk on any subject, so following Marcin&#8217;s talk, I watched <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/ratpack-a-toolkit-for-jvm-web-applications">Luke talk about building web applications</a> with <a target="_blank" href="http://www.ratpack.io/">Ratpack</a>. I love Ratpack, and I stay very close to the project&#8217;s continuing development, and try to contribute back when I can. Recently, I gave a talk at <a target="_blank" href="http://groovy.mn">GroovyMN</a> about building applications with Ratpack, but it&#8217;s such a fantastic opportunity of the conference to get to hear the framework&#8217;s lead developer talking on the subject, so I could not miss it. So much of the framework code in Ratpack is dedicated to documentation, that it becomes easy to quickly figure out how to get stuff done. Also, as <a target="_blank" href="https://twitter.com/CedricChampeau">Cedric Champeau</a> pointed out, Ratpack is perhaps the best example of writing Java APIs in a way that is optimized for use with Groovy. In the short few months that I&#8217;ve been really following Ratpack, I&#8217;ve already learned so much from Luke and the code he has written for Ratpack. His talk covered building a full-fledged Ratpack web application with Gradle, and covered top-down the range of scenarios that the majority of web-applications need to satisfy. This included everything from building handler chains to designing modules, to publishing static assets, to building RESTful APIs, to database access, and everything in between. He produced a fantastic reference application that is available on the <a target="_blank" href="https://github.com/ratpack/example-books">project&#8217;s GitHub page</a>. Luke&#8217;s entire presentation was slide-free and was full of hardcore demos and example coding. That&#8217;s part of the reason why I love to watch Luke talk, because his entire presentation is able to be used as reference material, and nearly all of them are like this.</p>
</div>
<div class="paragraph">
<p>Following Luke&#8217;s talk, I attended <a target="_blank" href="https://twitter.com/jeffscottbrown">Jeff Scott Brown</a>'s talk on <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/polyglot-programming-in-grails-2">polyglot development in Grails</a>. In this, he discussed and demonstrated how to make use of the <a target="_blank" href="http://grails.org/plugins/clojure">Grails Clojure plugin</a> to integrate Clojure code in your controllers and services. I hadn&#8217;t used the Clojure plugin before, but I did have a little bit of insight into the subject matter, since I had written the <a target="_blank" href="http://grails.org/plugins/js-controllers">Grails js-controllers plugin</a>, which allows you to develop controllers with JavaScript instead of Groovy. Jeff&#8217;s approach has the script executor auto-injected into all Grails artifacts, so that you can simply call a Clojure method as though it were a method attached to the injected <code>clj</code> object. For example, given some Clojure code:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint clojure language-clojure"><code>(ns "grails")

(defn add_numbers [x y]
  (+ x y))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then easily call the <code>add_numbers</code> method from your controller:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class MyController {
    def index(int x, int y) {
       def sum = clj.add_numbers(x, y)
       render ([answer: sum] as JSON)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a very nice capability, and let&#8217;s you adopt the pragmatic approach of "right tool for the job", which I firmly agree with. Some languages are better suited to handle certain tasks, and Jeff&#8217;s talk demonstrated how we can utilize Grails as a platform for polyglot application development. In the past, I&#8217;ve been quite outspoken with my belief that the web framework that will win in the long run is the one that supports a variety of languages. Indeed, that is why I decided at all to write the js-controllers plugin, because I feel it is necessary to allow developers to choose the right environment for their code. Using Grails as a platform for polyglot web development means that its rapid development and convention-over-configuration paradigm can be adopted by a myriad of developers coming from disparate backgrounds. I&#8217;m a very firm proponent of this, and I think that if you&#8217;re a Grails developer you owe it to yourself to see Jeff&#8217;s presentation on this subject.</p>
</div>
<div class="paragraph">
<p>I finished up the day with my first talk, <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/message-driven-architecture-in-grails">"Message Driven Architecture in Grails"</a>. This is a talk that I have given a few times in the past, most recently at SpringOne 2GX in September. I redesigned the talk quite a bit based off of feedback that I got after SpringOne, and as well to satsify a 45-minute timeframe (SpringOne 2GX has time-blocks of twice that amount). Mostly, the feedback that I got was that I spent too much time talking about mindset and methodology, and ultimately ran out of time for demos. So, for GGX I wanted to ensure that I had enough time to perform live-coding demonstrations and build a working example for the audience. Overall, I think that it went very well, and I had some great conversations with other conference goers following my presentation. I was nervous about cutting out some of the conversation related to the reasoning behind adopting a message-driven architecture approach, but all-in-all, the feedback that I got was very positive, and I fit everything that I wanted to in the alotted time, so I&#8217;m quite happy with the outcome of the talk. The video and slides for this presentation are available <a target="_blank" href="http://skillsmatter.com/podcast/home/message-driven-architecture-in-grails">here</a>, and the example application is available <a target="_blank" href="https://github.com/danveloper/ggx-2013-mda/">here</a>. Please don&#8217;t hesitate to reach out to me with feedback or questions.</p>
</div>
<div class="paragraph">
<p>Following the first day of the conference, the fine people from Skillsmatter took all of the conference goers out for drinks at a local pub. I had the opportunity there to hang out with <a target="_blank" href="http://twitter.com/antony">Antony Jones</a>, Luke Daley, and <a target="_blank" href="http://twitter.com/tomaslin">Tomas Lin</a>. We bullshitted on a range of subjects, and it was really a fantastic time; these are truly some of the smartest dudes that I know. Antony had to leave early because he&#8217;s not hardcore like the rest of us, but Luke, Tomas, and I had a ton of fun talking about everything from open source to family, and everything in between. After about five shots and ten beers a piece, Luke had to leave, and I found myself having a wondering conversation with a couple of London-local guys from the conference for about another hour or so. Shame on me, because their names escape me, but it was really fantastic to get to meet new people, and to hear their thoughts on the subjects discussed during the conference. Thankfully, Tomas, being very familiar with the area was able to instruct me on how to get back to my hotel, and I made it through my first full day in England without incident.</p>
</div>
<div class="paragraph">
<p>Day two of the conference started with an <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/road-to-grails-3-0">opening keynote from Grails project lead</a>, <a target="_blank" href="http://twitter.com/graemerocher">Graeme Rocher</a>, where he discussed the future of Grails and some of the decisions that they&#8217;re making to get to Grails 3. The next major release of Grails is going to revolutionize the framework, and set it up for long term success. During the keynote, Graeme announced that <a target="_blank" href="https://twitter.com/lhotari">Lari Hotari</a> will be joining the Grails core team. The announcement comes on the heels of <a target="_blank" href="https://twitter.com/burtbeckwith">Burt Beckwith</a> leaving the team, and the transition of adding Lari to the group was very classily handled by Graeme, et al. Lari is a long time contributor to Grails and brings a ton of experience in framework performance tuning. I had the opportunity to speak with him a few times during the conference, and his thoughts on the future of Grails are very intriguing; he will indeed be an excellent resource in the continued development of the framework. On more Grails specific details, Graeme announced that next major version of the framework will use Gradle as its build system, and will retire Gant. A resounding applause from the audience came from that announcement, though I&#8217;m not sure why. I think that Gant served an excellent purpose for Grails, and that the framework has merely outgrown it and needs to be suited to a more mature build system. I&#8217;m not sure that everybody who cheered really understands Gant, or its capabilities and limitations, though it was exciting to see such public affection for Gradle. Luke Daley is a core developer on the Gradleware team, so his close involvement with the Grails community means an excellent communication pipeline between the two projects, which bodes well for the future of Grails. Grails 3 will also introduce the notion of application profiles, where developers can choose to include only the framework components that they need. This will allow future Grails applications to maintain a lighter footprint when building micro-services or other thin-server architectures. Graeme also briefly covered some of the new features from the latest 2.3 release. He covered those details in more depth in a later session, which I also attended.</p>
</div>
<div class="paragraph">
<p>One thing that I made note of was the general adoption of Bintray&#8217;s JCenter over Maven Central for dependency resolution. I noticed during Luke&#8217;s Ratpack talk that his Gradle build file had a <code>jcenter()</code> directive in the <code>repositories</code> block, which he was using in favor of <code>mavenCentral()</code>. He also commented that JCenter is faster and much more secure, so it got me thinking that we should have similar functionality in Grails. Of course, with Groovy&#8217;s Grab now making use of JCenter and Gradle having explicit support for JCenter, most others in the audience were thinking the same thing. Lucky for me, I type much faster than everybody and was able to open a pull request to grails-core to add <code>jcenter()</code> as a repository configurator. With some changes after pointers from Graeme, I think we&#8217;ll soon see JCenter as a first-class repository in Grails. I&#8217;m proud to say that I got there first; indeed, Antony Jones commented that he had planned to make the same pull request later in the day.</p>
</div>
<div class="paragraph">
<p>I watched another talk from Luke Daley about building Grails applications with the <a target="_blank" href="https://github.com/grails/grails-gradle-plugin">Gradle Grails plugin</a>. The plugin is amazingly promising, and much work has been done on it, though I&#8217;m not sure that it has ever seen a non-snapshot release. <a target="_blank" href="https://twitter.com/johnrengelman">John Engleman</a>, who is also a Principal Consultant at <a target="_blank" href="http://objectpartners.com">Object Partners</a>, has done a bulk of work on the plugin for a multi-module project with <a target="_blank" href="http://www.gobloomhealth.com/">Bloom Health</a>, and Luke made sure to give proper shout-outs to John during the presentation. It&#8217;s great to see my colleagues at Object Partners having such a positive influence in the Groovy and Grails ecosystem, and I&#8217;m proud to consider myself John&#8217;s friend and coworker. The talk was again excellently technical, and gave practical examples for building a Grails application with Gradle. Some IDE support is still missing to make the plugin a truly seamless instrument over a regular Grails project, but using the plugin is really the only way to achieve a multi-module Grails project with Gradle, so everything that Luke demonstrated was compelling and fabulous reference material. If you actively developer a Grails application, this presentation is not to be missed. After watching the video of Luke giving this presentation at Gr8conf EU earlier in the year, I was left with enough detail and information to start my own multi-module Grails project. You can be sure that the content is very relevant and won&#8217;t leave you without direction if you want to start a project this way.</p>
</div>
<div class="paragraph">
<p>The REST and Async features the came from Grails 2.3 are some of the most impressive enhancements that the framework has seen. They are necessary improvements to keep Grails competitive in the increasingly real-time-web-application world. I had seen Graeme&#8217;s talk, <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/restfully-async-with-grails-2-3">"RESTfully Async with Grails 2.3"</a>, at SpringOne, but I think he covered more ground during GGX. Either that, or I was just paying better attention; both options are totally possible. During his presentation, Graeme answered a question for me that I had recently been working to figure out, and that is how to use a different classifier for resolving an entity when using a Resource in a RESTful manner. To be more plain, given the following URL Mappings:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class UrlMappings {
	static mappings = {
	  "/api/author"(resources: "author") {
        "/books"(resources: "book") {
          "/downloads"(resources: "download")
        }
	  }
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If I wanted to resolve a book&#8217;s author by name instead of ID, it&#8217;s now clear to me that I can construct a <code>RestfulController</code> in the following manner to satisfy this need:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class AuthorController extends RestfulController {
  AuthorController() {
    super(Author)
  }

  @Override
  protected Author queryForResource(Serializable ID) {
    def (first, last) = ID.split('-')
    Author.findByFirstNameAndLastName first, last
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From there, I can now make a request to the web application to get a list of Graeme&#8217;s books as such: <code>GET /api/authors/graeme-rocher/books</code>. Using this pattern, I can additionally create a <code>BookController</code> that extracts the book name in a similar fashion so that I may make a request to <code>GET /api/authors/graeme-rocher/books/the-definitive-guide-to-grails</code> to get the details for a particular book. I believe to make this work with HATEOAS and HAL that I&#8217;ll need to create a custom <code>HalJsonRenderer</code>, but that&#8217;s a sneaking suspicion that I haven&#8217;t tried to get working yet. For now, this works to obscure IDs when building a typical REST API structure.</p>
</div>
<div class="paragraph">
<p>I followed Graeme with my talk entitled <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/groovy-for-system-administrators">"Groovy for System Administrators"</a>. I put an obscene amount of preparation work into this presentation to make sure that it was compelling for those who attended. It was difficult to fit everything that I wanted to into a 45-minute block, and at times I had to speak very quickly to make sure that I&#8217;d finish in the allotted time. In the end, I think that it went very well, and I hope that I opened the door for more people in the Groovy community to make use of the language when designing their Systems Architecture. I broke the presentation down into three main sections of conversation related to system administration: Provisioning; Deployment; and Management. In each, I demonstrated how we can leverage Groovy to help automate and facilitate the tools in our system administrator toolbelt. With provisioning, I discussed how we can make use of Gradle&#8217;s build system to develop a "build" that creates server installation media that we can use when constructing new servers. I <a target="_blank" href="https://github.com/danveloper/provisioning-gradle-plugin">open sourced a Gradle plugin</a> that I have been developing that is responsible for creating an ISO installation image based off of some configuration that we define in our Gradle build file. The Gradle build file then becomes that server&#8217;s "definition", and can be a composed member of an infrastructure-wide Continuous Integration environment, as well as version controlled. In that, the plugin allows server definitions to be "built" when an application, or set of applications, is built with the CI tool, therein providing both the application and its "certified" runtime environment. For the purposes of provisioning, the plugin also allows for an unattended, automated deployment of a server based on the installation media that was generated during the build process. This essentially allows us to design a server for an application stack, version control its configuration, build it with continuous integration, and automatically deploy it when we&#8217;re ready for it. An example build script that makes use of the provisioning plugin looks something like this:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>provisioning {
  installImage = "http://www.gtlib.gatech.edu/pub/centos/6.4/isos/x86_64/CentOS-6.4-x86_64-netinstall.iso"

  // generated with "grub-crypt"
  rootpw       = '$6$M2N0GvDMV.hro4Nj$6/4W1SmGuWs8fscbdNLfp4fGFpEt93Y7kCNi8jnjN5JIkPy8YJGkkjCwImyXtCiheMyAkUR24IPgcrfeIliB7/'

  vbox {
    apiUrl = "http://localhost:18083"
    name   = "web"
    x64    = true
    memory = 1024
    disk   = 8589934592
  }

  network {
    device("eth0") {
      bootproto = DHCP
      onboot    = true
      ipv6      = false
    }
  }

  partitioning {
    clear(init: true)

    part {
      mntpoint = "/"
      fstype   = "ext4"
      size     = 1
      grow     = true
    }

    part {
      mntpoint    = "swap"
      recommended = true
    }
  }

  packages {
    // or, perhaps more preferrably, a network-local repo
    url "http://www.gtlib.gatech.edu/pub/centos/6.4/os/x86_64/"

    // some other repo
    repo("extra") {
      "http://192.168.0.106/project-repo"
    }

    // kickstart package groups
    group "base"
    group "core"
    group "console-internet"
    group "server-platform"

    // These packages come from the "extra" repo
    pkg   "jdk"
    pkg   "apache-tomcat"
    pkg   "hello-webapp"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The plugin&#8217;s DSL provides granular control over all aspects of the server&#8217;s configuration, including its network configuration and disk partitioning layout. Presently, the plugin only supports automatic deployment to VirtualBox, but in practice I use the plugin with VMware vCloud on an ESXi infrastructure. I haven&#8217;t had time to fine-tune the vCloud deployment code, so I wasn&#8217;t comfortable releasing it during the conference, but I promise to in the coming months.</p>
</div>
<div class="paragraph">
<p>For the aspects of system administration related to deployment, I discussed how to make use of <a target="_blank" href="https://github.com/craigwblake/redline">a java library for developing RPM packages</a> in a Gradle build file to package web applications in a format that could be easily distributed to the provisioned server environment. For this, we need only use Gradle&#8217;s ability to define tasks as Groovy closures, and we can bundle our already-built web-application in a server-friendly format. Consider the following <code>rpm</code> task on a web application&#8217;s build script:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>import org.freecompany.redline.*

task(rpm, dependsOn: 'war') &lt;&lt; {
  def builder = new Builder()
  builder.setPackage("hello-webapp", "0.1-snapshot", "1")
  builder.setGroup("Java Development");
  builder.setType(org.freecompany.redline.header.RpmType.BINARY);
  builder.setPlatform(org.freecompany.redline.header.Architecture.NOARCH, org.freecompany.redline.header.Os.LINUX);
  builder.setSummary("")
  builder.license = ""
  builder.packager = ""
  builder.vendor = ""
  builder.url = ""
  builder.provides = "hello-webapp"
  def prefix = "/opt/apache-tomcat/webapps"
  def file = new File(project.buildDir, "libs/provisioning-webapp-test.war")
  builder.addFile("$prefix/$file.name", file, 07777, 07777, "root", "wheel")
  builder.build(project.buildDir)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this process, we can define the exact location that our war will be deployed, and (not demonstrated) we can also build post-installation scripts into the RPM package so that we can handle deployment-specific tasks like restarting the web server. I&#8217;ve since learned that this wheel has been reinvented a number of times, and there are a handlful of Gradle plugins out there for building RPMs, including <a target="_blank" href="https://github.com/cloudfoundry/java-gradle-rpm-plugin">one really great one from the CloudFoundry team</a>. However the bread gets slices, the principle remains the same: for deployments, package your application in a server-friendly format, and Gradle is an excellent utility to facilitate that process.</p>
</div>
<div class="paragraph">
<p>The third and final part of the presentation&#8217;s conversation covered managing servers after provisioning and application deployment. I discussed how we can leverage the Groovy ecosystem to help with user management and to programmatically define access control, but the practices that I demonstrated can apply to a wide range of system administration tasks beyond those simple two. One point that I worked to convey is the reality that infrastructure is moving away from being system-centric to a more application-centric environment. To that end, it makes sense for us to start developing our systems architecture in a way that recognizes the application stack as the managing authority, and to integrate things like authentication with our application&#8217;s authentication scheme. This may be a tough pill to swallow for those who have built environments that rely heavily on operation-system-oriented authentication, or domain-level user directories&#8201;&#8212;&#8201;for example, Kerberos and LDAP&#8201;&#8212;&#8201;because it changes the paradigm to have the application stack manage the server environment. I think this is an important shift, because it is clearly obvious that organizations are moving to structures that are more increasingly looking to the development community for answers to business problems. So if we design the server architecture in a way that makes use of an application&#8217;s authentication protocol, we can then make our application stack the single souce of truth for both server and application authentication and authorization. To demonstrate this, I modified a server&#8217;s <a target="_blank" href="https://www.kernel.org/pub/linux/libs/pam/whatispam.html">Pluggable Authentication Module (PAM)</a> configuration to reach out to a Grails application that was backed by Spring Security. PAM ships with a module, <code>pam_exec.so</code>, that allows an external script to influence any part of the stacked PAM process, so as a proof of concept, a simple bash script can be fashioned to authenticate a user logging into the server:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint bash language-bash"><code>#!/bin/sh
pass=`cat`;
result=$(curl -s -d "user=$PAM_USER&amp;pass=$pass" http://192.168.0.106:8080/grails-springsec/auth)
if [ "$result" != "success" ]; then
  exit 1;
else
  /usr/sbin/useradd $PAM_USER -m -k /etc/skel
  exit 0;
fi</code></pre>
</div>
</div>
<div class="paragraph">
<p>A controller on the Grails application maps to <code>/auth</code> and returns a basic text message indicating whether or not the login attempt was successful.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="prettyprint groovy language-groovy"><code>class AuthController {
  AuthenticationManager authenticationManager

  def index() {
    def token = new UsernamePasswordAuthenticationToken(params.user, params.pass)
    try {
      authenticationManager.authenticate(token)
      render "success"
    } catch (BadCredentialsException e) {
      render "failure"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code, of course, would need some heavy refinement before it could be considered for production purposes, but the proof-of-concept shows how simple the path can be to move from system-centric to application-centric, and how we can leverage Groovy (in this case, Grails) to get there.</p>
</div>
<div class="paragraph">
<p>As the final part to my presentation, I wanted to demonstrate how we can leverage Groovy to build programmatic access control to low-level system processes. To show this, I built a kernel module (in C) that overwrote the <code>__NR_mkdir</code> call kernel&#8217;s <code>syscall_table</code>, to instead delegate <code>mkdir</code> requests to a Groovy script. In turn, the Groovy script would be responsible for determining if the directory was allowed to be made, and would instruct the kernel module to proceed or fail accordingly. Because of the nature of the Linux kernel, there&#8217;s some leg-work that needs to be done allow the kernel module to make a call to a Groovy script. The kernel module is running in "Kernel Space", which has its own memory mapping and processing cycles that are different from "User Space", where the Groovy script is running. There are a few different ways to get a kernel module to talk to a user-space process, and I covered them briefly in my presentation, but ultimately the best answer was to craft an RPC-style system that operated over UDP. Since we can do network programming very easily in Groovy, and fairly easily from within a kernel module, it made sense that a UDP client/server be the underpinning for the IPC. Although this part of the presentation merely demonstrated overriding <code>mkdir</code> calls, the premise of the conversation was to demonstrate how we can leverage Groovy, which is a very high-level faculty, to influence low-level operations, and to do so in a very programmatically concise way.</p>
</div>
<div class="paragraph">
<p>The feedback that I received from the presentation was very positive, and I hope to have the opportunity to expound on the topic during next summer&#8217;s Gr8conf. The video and slides for the presentation are <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/groovy-for-system-administrators">freely available for viewing on the GGX site</a>, the code is <a target="_blank" href="https://github.com/danveloper/ggx-2013-grsysadmin">available on my GitHub</a>.</p>
</div>
<div class="paragraph">
<p>After my presentation, I sat in on Tomas Lin&#8217;s talk about <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/building-lightning-fast-rest-services-with-dropwizard-and-groovy">building RESTful micro-services in Groovy with Dropwizard</a>. It&#8217;s not inconsiderate the amount of discussion there was on REST services during GGX, but Tomas delivers an unparalleled expertise on the topic. His talk was derived from real-world experiences that demonstrated using Dropwizard in a very practical way, and I quite enjoyed the material. Tomas showed how to use <a target="_blank" href="https://github.com/pledbrook/lazybones">LazyBones</a> to create a Gradle-backed Dropwizard project. He also showed how to use Spock to test the Resources that are exposed through the Jersey endpoints that Dropwizard exposes. Through an example project, he discussed how to leverage the framework to produce the correct HTTP responses, including scenarios with failed validation. Furthermore, he discussed Dropwizard&#8217;s "metrics" capabilities, where he noted that exposing metrics is about allowing a central authority to coordinate the behavior of your application&#8217;s environment. For example, response metrics may indicate that your REST service needs some of the load taken off, so your environment can coordinate the spooling-up of another instance to take care of some of the work load. It&#8217;s quite compelling the possibilities that we have today to build resilient, fully-automated application infrastructures, and Tomas depicts that nicely in this talk.</p>
</div>
<div class="paragraph">
<p>I was disappointed that I had to miss <a target="_blank" href="https://twitter.com/davidthecoder">Dave Dawson</a>'s <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/groovy-micro-services-with-spring-boot">talk on Spring Boot</a>, but during the same block I gave my third and final talk to finish up the conference presentations. This last talk was on <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/application-architecture-in-groovy-4945">"Application Architecture in Groovy"</a>, and it&#8217;s one that I&#8217;d given earlier this year at both Gr8conf US and SpringOne 2GX. Gr8conf US was the first time that I had shared my formulated opinions on building applications with Groovy, and for SpringOne 2GX I drastically refined the talk to cover the material in what I felt to be a more cohesive manner. So, I built the talk for GGX based on the material that I had written for SpringOne 2GX, and had to drop some parts so that I could fit all of the details into the 45-minute presentation time. Overall, I felt very good about the presentation, and thought that dropping some conversation in favor of demonstration code actually worked out pretty well.</p>
</div>
<div class="paragraph">
<p>There were a number of presentations on Groovy architecture during GGX, and Luke Daley shared a sentiment about that fact, which I tend to agree with. He said (paraphrasing), when you start to see a proliferation of conference talks about architecture with a particular language or framework, it shows a growing maturity in the ecosystem because people want to know the best ways to use this stuff. I felt that about summed up the general tone of the conference, which had an obviously different feel from SpringOne 2GX from just a few years ago. Here, today, it feels like Groovy is a powerful language on the JVM (which it is), and not just some toy project, and its adoption within the greater Java community proves that its formidible and here to stay.</p>
</div>
<div class="paragraph">
<p>To close out the conference, we had a <a target="_blank" href="http://skillsmatter.com/podcast/groovy-grails/park-bench-panel-discussion-with-pizza-beer-4753">"park bench panel" discussion</a>, where <a target="_blank" href="http://twitter.com/pledbrook">Peter Ledbrook</a>, <a target="_blank" href="http://twitter.com/russel_winder">Russel Winder</a>, Jeff Scott Brown, Cedric Champeau, Luke Daley, Guillaume Laforge, <a target="_blank" href="http://twitter.com/smaldini">Stephane Maldini</a>, and myself made ourselves available for general questions from the audience of conference goers. There were some great questions from the bunch, mostly about Grails. Truthfully, I weaseled my way on to the panel, so as to provide some entertainment and to keep the conversation interesting. Peter, as any fine friend would, graciously indulged me, and allowed me to sit amongst the experts whilst tweeting and taking selfies to keep the energy flowing in the group. Jeff fielded the majority of the questions, as they were mostly Grails-related, but there was some non-Grails specific conversation where the rest of us had some input. I think the panel was a really cool idea, and it served nicely as an opportunity to present questions that had been formulated through the course of the conference. I&#8217;d like to see this same kind of thing during Gr8conf and SpringOne, because I believe that those conference&#8217;s attendence groups bring different thoughts and ideas to the table, so it would be great to see them given the same opportunities.</p>
</div>
<div class="paragraph">
<p>Following the close of the conference, everybody went to a nearby pub for drinks and a few shots. It was relieving to be done with my presentations, and to finally have months and months of hard work presented. Indeed, the work that goes into making a conference presentation is After just a short period of time, I felt the exhaustion catch up to me and I had to abandon Jeff, Luke, Tomas, Soren, and the other Gr8conf Danes to go back to my hotel and crash. I wish that I&#8217;d had more time (and energy!) to spend with the bunch; I was really enjoying the chance to catch up with everybody since we&#8217;d last met at SpringOne. Alas, I&#8217;ll see them again&#8201;&#8212;&#8201;hopefully soon&#8201;&#8212;&#8201;and we&#8217;ll share ale and sing songs of our triumphs. I really look forward to that.</p>
</div>
<div class="paragraph">
<p>Special thanks to Skillsmatter for putting on the conference and for coordinating international travel and accommodations for me. I hope to be a part of GGX next year, and the year after, and the year after, and the year &#8230;. you get the point :-). To note: amazingly, <i>all</i> videos and slides from the conference presentations are online and freely available on the <a target="_blank" href="http://skillsmatter.com/event/groovy-grails/groovy-grails-exchange-2013">GGX page at the Skillsmatter site</a>.</p>
</div>

</div>
</div>

</div>
</body>
</html>
